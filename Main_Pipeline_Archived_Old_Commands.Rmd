---
title: "Archived from Main_Pipeline"
output: html_document
---

```{r Convert Agilent data to mzML, include=FALSE}
'msconvert *.d -o mzML'
```

```{r Load data, include=FALSE}
path.pos <- "data/Rik/ESI+" #### path to converted positive mzML files
path.neg <- "data/Rik/ESI-"

### Creating sub-directories for samples/batches are allowed and recommended
pos.mzml <- list.files(path.pos, recursive = T, full.names = T, pattern=".mzML")
pos.mzml

neg.mzml <- list.files(path.neg, recursive = T, full.names = T, pattern=".mzML")
neg.mzml
```

**PEAK PICKING METHOD**  
- 'matchedfilter' is used by default (when 'xcmsSet' method is used for loading data)  
- 'centWave' is commonly used for high resolution spectra/MS data  
- Irregardless of the peak picking method chosen, there are many parameters that can be tuned. The rule of thumb is, if you do not understand what a parameter exactly does, then it is best to use the default value.  
- "Mass deviation μ in ppm, typically set to a generous multiple of the mass accuracy of the mass spectrometer. We use μ = 30 ppm for the Bruker MicrOTOF-Q, which is advertised with a mass accuracy of 3–5 ppm". (doi: 10.1186/1471-2105-9-504)  
- Q: How do we find the best tuning parameters for our dataset? (e.g. 'fwhm' specifies full width at half maximum (default is 30s) based on the type of chromatography)  
- Q: Is it a good idea to load all sample sets (Fresh, Frozen 24h, Frozen 1w) into one xcmsSet?

```{r xcmsSet / peak identification}
param.ppm <- 30
param.snthresh <- 65
param.prefilter <- c(5, 10000)
param.noise <- 6500
param.peakwidth <- c(12,28)
param.parallelization <- MulticoreParam(floor(detectCores() * 0.9)) ### use 90% of the cores for parallel computing

xset.pos.centw <- xcmsSet(pos.mzml, method = "centWaveWithPredictedIsotopeROIs", 
                          ppm = param.ppm, 
                          snthresh = param.snthresh, 
                          prefilter = param.prefilter, 
                          noise = param.noise, 
                          peakwidth = param.peakwidth,
                          BPPARAM = param.parallelization)

xset.pos.mquant <- xcmsSet(pos.mzml, method = "massifquant", 
                           withWave = TRUE, 
                           ppm = param.ppm, 
                           snthresh = param.snthresh, 
                           prefilter = param.prefilter, 
                           noise = param.noise, 
                           peakwidth = param.peakwidth,
                           BPPARAM = param.parallelization)

param.neg.ppm <- 30
param.neg.snthresh <- 30
param.neg.prefilter <- c(5, 9000)
param.neg.noise <- 4500
param.neg.peakwidth <- c(12,35)

xset.neg.centw <- xcmsSet(neg.mzml, method = "centWaveWithPredictedIsotopeROIs", 
                          ppm = param.neg.ppm, 
                          snthresh = param.neg.snthresh, 
                          prefilter = param.neg.prefilter, 
                          noise = param.neg.noise, 
                          peakwidth = param.neg.peakwidth,
                          BPPARAM = param.parallelization)

xset.neg.mquant <- xcmsSet(neg.mzml, method = "massifquant", 
                           withWave = TRUE, 
                           ppm = param.neg.ppm, 
                           snthresh = param.neg.snthresh, 
                           prefilter = param.neg.prefilter, 
                           noise = param.neg.noise, 
                           peakwidth = param.neg.peakwidth,
                           BPPARAM = param.parallelization)
```


```{r Viewing the constructed xcmsSet, echo=FALSE}
xset.pos.centw
xset.pos.mquant
xset.neg.centw
xset.neg.mquant
```


```{r Peaks}
message(paste0("Sample groups: "))
print(levels(sampclass(xset.pos.centw)))
head(xset.pos.centw@peaks)
dim(xset.pos.centw@peaks)

message(paste0("Sample groups: "))
print(levels(sampclass(xset.pos.mquant)))
head(xset.pos.mquant@peaks)
dim(xset.pos.mquant@peaks)

message(paste0("Sample groups: "))
print(levels(sampclass(xset.neg.centw)))
head(xset.neg.centw@peaks)
dim(xset.neg.centw@peaks)

message(paste0("Sample groups: "))
print(levels(sampclass(xset.neg.mquant)))
head(xset.neg.mquant@peaks)
dim(xset.neg.mquant@peaks)
```

**mz** Intensity weighted mean of m/z values of the peak across scans.  
**mzmin** Minimum m/z of the peak.  
**mzmax** Maximum m/z of the peak.  
**rt** Retention time of the peak’s midpoint.  
**rtmin** Minimum retention time of the peak.  
**rtmax** Maximum retention time of the peak.  
**into** Integrated (original) intensity of the peak.  
**intf** Integrated intensity of the filtered peak.  
**maxo** Maximum intensity of the peak.  
**maxf** Maximum intensity of the filtered peak.  
**i** Rank of peak in merged EIC (<= max).  
**sn** Signal to noise ratio of the peak  

- Grouping has its own methods too (density, mzClust, nearest)  
Q: How do we tune grouping parameters? How do we find the best ones for our data?  
```{r Grouping peaks representing the same analyte across samples / matching peaks across samples}
#?group.density
#?group.mzClust
#?group.nearest

#xsg.pos <- group(xset.pos, sleep = 0.02)

xsg.pos.centw <- group(xset.pos.centw)
xsg.pos.mquant <- group(xset.pos.mquant)

xsg.neg.centw <- group(xset.neg.centw)
xsg.neg.mquant <- group(xset.neg.mquant)

xsg.pos.centw.mzClust <- group.mzClust(xset.pos.centw, mzppm = 5)
xsg.pos.mquant.mzClust <- group.mzClust(xset.pos.mquant, mzppm = 5)

xsg.neg.centw.mzClust <- group.mzClust(xset.neg.centw, mzppm = 5)
xsg.neg.mquant.mzClust <- group.mzClust(xset.neg.mquant, mzppm = 5)
```


There are a few retention time correction methods in xcms: Gaussian, Symmetric, and Obiwarp.  
Plot shows the data points used for regression and the resulting deviation profiles. It can be used for supervising the algorithm. The distribution of peak groups across retention time is also shown in the plot.  
```{r Retention time correction}
xsg.pos.centw.retcor <- retcor(xsg.pos.centw, family="gaussian", plottype="mdevden")
xsg.pos.mquant.retcor <- retcor(xsg.pos.mquant, family="gaussian", plottype="mdevden")

xsg.neg.centw.retcor <- retcor(xsg.neg.centw, family="gaussian", plottype="mdevden")
xsg.neg.mquant.retcor <- retcor(xsg.neg.mquant, family="gaussian", plottype="mdevden")

xsg.pos.centw.mzClust.retcor <- retcor(xsg.pos.centw.mzClust, family="gaussian", plottype="mdevden")
xsg.pos.mquant.mzClust.retcor <- retcor(xsg.pos.mquant.mzClust, family="gaussian", plottype="mdevden")

xsg.neg.centw.mzClust.retcor <- retcor(xsg.neg.centw.mzClust, family="gaussian", plottype="mdevden")
xsg.neg.mquant.mzClust.retcor <- retcor(xsg.neg.mquant.mzClust, family="gaussian", plottype="mdevden")

#xsg.pos.retcor.symmetric <- retcor(xsg.pos, family="symmetric", plottype="mdevden")
#xsg.pos.retcor.obiwarp <- retcor.obiwarp(xsg.pos, plottype="deviation")

xsg.pos.centw.retcor.obiwarp <- retcor.obiwarp(xsg.pos.centw, plottype="deviation")
xsg.pos.mquant.retcor.obiwarp <- retcor.obiwarp(xsg.pos.mquant, plottype="deviation")

xsg.neg.centw.retcor.obiwarp <- retcor.obiwarp(xsg.neg.centw, plottype="deviation")
xsg.neg.mquant.retcor.obiwarp <- retcor.obiwarp(xsg.neg.mquant, plottype="deviation")

xsg.pos.centw.mzClust.retcor.obiwarp <- retcor.obiwarp(xsg.pos.centw.mzClust, plottype="deviation")
xsg.pos.mquant.mzClust.retcor.obiwarp <- retcor.obiwarp(xsg.pos.mquant.mzClust, plottype="deviation")

xsg.neg.centw.mzClust.retcor.obiwarp <- retcor.obiwarp(xsg.neg.centw.mzClust, plottype="deviation")
xsg.neg.mquant.mzClust.retcor.obiwarp <- retcor.obiwarp(xsg.neg.mquant.mzClust, plottype="deviation")
```


When re-grouping the retention time-corrected xset, parameters can also be re-tuned once more. For example, we can choose a narrower 'bw'.  
```{r Re-grouping peaks representing the same analyte across samples. Grouping/retention time correction can and must be repeated several times}
xsg.gaus.pos <- group(xsg.pos.mquant.mzClust.retcor.obiwarp)
xsg.gaus.pos <- retcor.obiwarp(xsg.gaus.pos, plottype="deviation")
xsg.gaus.pos <- group(xsg.gaus.pos)

xsg.gaus.neg <- group(xsg.neg.mquant.mzClust.retcor.obiwarp)
xsg.gaus.neg <- retcor(xsg.gaus.neg, family="gaussian", plottype="mdevden")
xsg.gaus.neg <- group(xsg.gaus.neg)

#xsg.sym <- group(xsg.pos.retcor.symmetric, bw=10)
#xsg.obw <- group(xsg.pos.retcor.obiwarp, bw=10)
```


```{r Fill in missing peaks using original data, message=FALSE, warning=FALSE}
xsg.gaus.pos <- fillPeaks(xsg.gaus.pos)
xsg.gaus.neg <- fillPeaks(xsg.gaus.neg)
#xsg.sym <- fillPeaks(xsg.sym)
#xsg.obw <- fillPeaks(xsg.obw)
```


"into" and "maxo" are (or at least seem to be) peak intensities and areas, respectively.  
Peak list:  
```{r Results of peak detection}
peaks(xsg.gaus.pos)[1:25,]
dim(xsg.gaus.pos@peaks)
#dim(peaks(xsg.gaus.pos)) ### Another way of doing what was done in the previous line

peaks(xsg.gaus.neg)[1:25,]
dim(xsg.gaus.neg@peaks)
```

‘diffreport’ computes Welch's two-sample t-statistic for each analyte and ranks them by p-value. In brief, it performs univariate analysis on our peaks.  
Q: When using 'diffreport', it is possible to include three sample classes (or even many more) by defining the class1/class2 arguments as c("sample2","sample3"). Does that, however, have any impact on the final result? In brief, is there a difference between `class1=c("Mouse1", "Mouse2"), class2="Mouse5"` and `class1="Mouse1", class2=c("Mouse2","Mouse5")`  
```{r Extracting ion chromatograms for significant ions and reporting the most statistically significant differences in analyte intensities / A report showing the most significant differences between two sets of samples, message=FALSE}
rep.gaus.pos <- diffreport(object = xsg.gaus.pos, 
                       class1 = levels(sampclass(xsg.gaus.pos))[1], 
                       class2 = levels(sampclass(xsg.gaus.pos))[2], 
                       filebase = "diffreport_ESI_pos", eicmax = 40, 
                       sortpval = TRUE,
                       metlin = 0.5, mzdec = 5)

rep.gaus.neg <- diffreport(object = xsg.gaus.neg, 
                       class1 = levels(sampclass(xsg.gaus.neg))[1], 
                       class2 = levels(sampclass(xsg.gaus.neg))[2], 
                       filebase = "diffreport_ESI_neg", eicmax = 40, 
                       sortpval = TRUE,
                       metlin = 0.5, mzdec = 5)

#### quality of peaks can be inspected by checking the figures in report_eic folder

#rep.sym <- diffreport(xsg.sym, "Fresh", c("Frozen 1w", "Frozen 24h"), "Symmetric", 10, metlin=0.15)
#rep.obw <- diffreport(xsg.obw, "Fresh", c("Frozen 1w", "Frozen 24h"), "Obiwarp", 10, metlin=0.15)

rep.gaus.pos[1:25,]
tail(rep.gaus.pos)

rep.gaus.neg[1:25,]
tail(rep.gaus.neg)

#rep.sym[1:10,]
#rep.obw[1:10,]
```

```{r DifferentPeaks}
eic <- list.files("diffreport_eic", full.names = T, recursive = T)
im <- list()
for(i in 1:length(eic)) {
  im[[i]] <- load.image(eic[i])
  plot(im[[i]])
  }
```


```{r Constructing peak intensity matrix for multivariate analysis using MetaboAnalyst.ca}
#– Features (peaks) are in rows
#– Samples are in  columns
#– Group labels must be added by using 'phenoData'
#- If there are duplicated mzRT values in the rows of the generated peak intensity matrix, MetaboAnalyst will result in an error. To fix this error, simply distinguish repeated values by adding 'A', 'B', 'C', etc. to them. For example, if you have the mzRT feature 54.04/1499.3 twice in the resulting table, simply change the second one to 54.04/1499.3A
dat <- groupval(xsg.gaus.pos, "medret", "into")
rownames(dat) <- groupnames(xsg.gaus.pos, mzdec=5, rtdec=5)
dat <- rbind(group = as.character(phenoData(xsg.gaus.pos)$class), dat)
write.csv(dat, file='ESI+_PeakIntensityMatrix_MetaboAnalyst.csv')
head(dat)
tail(dat)
#rm(dat)

datneg <- groupval(xsg.gaus.neg, "medret", "into")
rownames(datneg) <- groupnames(xsg.gaus.neg, mzdec=5, rtdec=5)
datneg <- rbind(group = as.character(phenoData(xsg.gaus.neg)$class), datneg)
write.csv(datneg, file='ESI-_PeakIntensityMatrix_MetaboAnalyst.csv')
head(datneg)
tail(datneg)
#rm(datneg)

#dat <- groupval(xsg.sym, "medret", "into")
#dat <- rbind(group = as.character(phenoData(xsg.sym)$class), dat)
#write.csv(dat, file='Symmetric_PeakIntensityMatrix.csv')
#rm(dat)

#dat <- groupval(xsg.obw, "medret", "into")
#dat <- rbind(group = as.character(phenoData(xsg.obw)$class), dat)
#write.csv(dat, file='Obiwarp_PeakIntensityMatrix.csv')
#rm(dat)
```

```{r Extracted ion chromatogram (EIC) / Assessing the quality of detected peaks}
#gt.gaus <- groups(xsg.gaus)
#gt.gaus[1:3,]

#gt.sym <- groups(xsg.sym)
#gt.sym[1:3,]

#gt.obw <- groups(xsg.obw)
#gt.obw[1:3,]

#grp_idx_gaus <- which(gt.gaus[,"rtmed"] > 0 & gt.gaus[,"rtmed"] < 500 & gt.gaus[,"npeaks"] > 50)[1]
#eiccor.gaus <- getEIC(xsg.gaus, groupidx=grp_idx_gaus)
#plot(eiccor.gaus, col=as.numeric(phenoData(xsg.gaus)$class))
```


Processing with peakML  
```{r PeakML}
source ("http://puma.ibls.gla.ac.uk/mzmatch.R/install_mzmatch.R")
.jinit ()
mzmatch.init()
PeakML.xcms.write(xsg.gaus.neg, "xsg_gaus_neg.peakml")
mzmatch.init(version.1 = FALSE)
mzmatch.ipeak.sort.MetAssign(JHeapSize = 180000, i = "xsg_gaus_neg.peakml", o = "xcms_identified.peakml", 
                             basepeaks = "xcms_basepeaks.peakml", ppm = 3, numDraws = 300, burnIn = 200, 
                             adducts = "M+H,M+NH4", 
                             dbIdentOut = "xcms_neg_Probabilistic_metabolite_annotation.csv", v = TRUE)

### PeakML.Viewer() ### Load generated peakML files
```

```{r apLCMS pipeline}
#####This section is currently under construction (apLCMS might not be as reliable as xcms)
#apLCMS.set <- apLCMS::cdf.to.ftr(path.pos, file.pattern = ".mzXML")
```
