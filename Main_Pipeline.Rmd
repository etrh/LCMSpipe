---
title: "Pipeline for Analysis of Metabolomics Data in R"
author: "Ashkan Zareie"
date: "August-September 2017"
output: html_document
---
  
  
On UNIX-based systems you will first need to ensure that the following requirements are installed:  
  `sudo apt-get install -y libxml2-dev libcurl4-openssl-dev libssl-dev netcdf-bin libnetcdf-dev gfortran libblas-dev liblapack-dev libpcre++-dev liblzma-dev libbz2-dev libgtk2.0-dev bwidget libglu1-mesa-dev freeglut3-dev mesa-common-dev default-jre default-jdk`
  
  
```{r Setup, include=FALSE}
# # # # - - - - IMPORTANT: make sure you have the latest version of R installed - - - - # # # #

update.packages()
#update.packages(repos = "https://cloud.r-project.org/")

if(!require(pacman)){install.packages("pacman")}

source("http://bioconductor.org/biocLite.R")
if(!require(MSnbase)){biocLite("MSnbase", dependencies = TRUE)}
if(!require(xcms)){biocLite("xcms", dependencies = TRUE)}
if(!require(CAMERA)){biocLite("CAMERA", dependencies = TRUE)}
if(!require(IPO)){biocLite("IPO", dependencies = TRUE)}

#Development versions of MSnbase and xcms
#if(!require(MSnbase)){biocLite("lgatto/MSnbase")}
#if(!require(xcms)){devtools::install_github("sneumann/xcms", ref = "xcms3")}

necessary_packages <- c("devtools", "ROCS", "rJava", "plotly", "ptw", "tcltk2", "pca3d", "imager")

pacman::p_load("Rserve", "som", "ROCR", "RJSONIO", "Cairo", 
               "pheatmap", "lattice", "pROC", "ellipse", 
               "scatterplot3d", "siggenes", "globaltest", 
               "GlobalAncova", "Rgraphviz", "KEGGgraph", 
               "SSPA", "sva", "car", "fitdistrplus", 
               "R.utils", "metabomxtr", "rvest")

install.necessary.packages <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) install.packages(new.pkg)
}

install.necessary.packages(necessary_packages)
#install.necessary.packages(required_by_metaboanalyst)

if(!require(MetaboAnalystR)){devtools::install_github("xia-lab/MetaboAnalystR", 
                                                      build_vignettes = TRUE)}
#vignette(package="MetaboAnalystR")

update.packages()
source("https://bioconductor.org/biocLite.R")
biocLite()
tryCatch({biocLite("BiocUpgrade")}, error=function(e){print(paste(conditionMessage(e)))})
biocValid()

devtools::install_github("stanstrup/QC4Metabolomics/MetabolomiQCsR")

library(MSnbase)
library(xcms)
library(CAMERA)
library(IPO)
library(MetaboAnalystR)

library(doParallel)
library(RColorBrewer)

library(plotly)
library(rJava)
```

```{r Convert data}
'msconvert *.d -o mzML'
```

```{r Load data, include=FALSE}
path.pos <- "data/Rik/ESI+" ####path to converted mzXML files
path.neg <- "data/Rik/ESI-"

###Creating sub-directories for samples/batches are allowed and recommended
pos.mzml <- list.files(path.pos, recursive = T, full.names = T, pattern=".mzML")
pos.mzml

neg.mzml <- list.files(path.neg, recursive = T, full.names = T, pattern=".mzML")
neg.mzml
```

**PEAK PICKING METHOD**  
- 'matchedfilter' is used by default (when 'xcmsSet' method is used for loading data)  
- 'centWave' is commonly used for high resolution spectra/MS data  
- Irregardless of the peak picking method chosen, there are many parameters that can be tuned. The rule of thumb is, if you do not understand what a parameter exactly does, then it is best to use the default value.  
- "Mass deviation μ in ppm, typically set to a generous multiple of the mass accuracy of the mass spectrometer. We use μ = 30 ppm for the Bruker MicrOTOF-Q, which is advertised with a mass accuracy of 3–5 ppm". (doi: 10.1186/1471-2105-9-504)  
- Q: How do we find the best tuning parameters for our dataset? (e.g. 'fwhm' specifies full width at half maximum (default is 30s) based on the type of chromatography)  
- Q: Is it a good idea to load all sample sets (Fresh, Frozen 24h, Frozen 1w) into one xcmsSet?

```{r xcmsSet / peak identification}
param.ppm <- 30
param.snthresh <- 65
param.prefilter <- c(5, 10000)
param.noise <- 6500
param.peakwidth <- c(12,28)
param.parallelization <- MulticoreParam(floor(detectCores() * 0.9)) ### use 90% of the cores for parallel computing

xset.pos.centw <- xcmsSet(pos.mzml, method = "centWaveWithPredictedIsotopeROIs", 
                          ppm = param.ppm, 
                          snthresh = param.snthresh, 
                          prefilter = param.prefilter, 
                          noise = param.noise, 
                          peakwidth = param.peakwidth,
                          BPPARAM = param.parallelization)

xset.pos.mquant <- xcmsSet(pos.mzml, method = "massifquant", 
                           withWave = TRUE, 
                           ppm = param.ppm, 
                           snthresh = param.snthresh, 
                           prefilter = param.prefilter, 
                           noise = param.noise, 
                           peakwidth = param.peakwidth,
                           BPPARAM = param.parallelization)

param.neg.ppm <- 30
param.neg.snthresh <- 30
param.neg.prefilter <- c(5, 9000)
param.neg.noise <- 4500
param.neg.peakwidth <- c(12,35)

xset.neg.centw <- xcmsSet(neg.mzml, method = "centWaveWithPredictedIsotopeROIs", 
                          ppm = param.neg.ppm, 
                          snthresh = param.neg.snthresh, 
                          prefilter = param.neg.prefilter, 
                          noise = param.neg.noise, 
                          peakwidth = param.neg.peakwidth,
                          BPPARAM = param.parallelization)

xset.neg.mquant <- xcmsSet(neg.mzml, method = "massifquant", 
                           withWave = TRUE, 
                           ppm = param.neg.ppm, 
                           snthresh = param.neg.snthresh, 
                           prefilter = param.neg.prefilter, 
                           noise = param.neg.noise, 
                           peakwidth = param.neg.peakwidth,
                           BPPARAM = param.parallelization)
```


```{r Viewing the constructed xcmsSet, echo=FALSE}
xset.pos.centw
xset.pos.mquant
xset.neg.centw
xset.neg.mquant
```


```{r Peaks}
message(paste0("Sample groups: "))
print(levels(sampclass(xset.pos.centw)))
head(xset.pos.centw@peaks)
dim(xset.pos.centw@peaks)

message(paste0("Sample groups: "))
print(levels(sampclass(xset.pos.mquant)))
head(xset.pos.mquant@peaks)
dim(xset.pos.mquant@peaks)

message(paste0("Sample groups: "))
print(levels(sampclass(xset.neg.centw)))
head(xset.neg.centw@peaks)
dim(xset.neg.centw@peaks)

message(paste0("Sample groups: "))
print(levels(sampclass(xset.neg.mquant)))
head(xset.neg.mquant@peaks)
dim(xset.neg.mquant@peaks)
```

**mz** Intensity weighted mean of m/z values of the peak across scans.  
**mzmin** Minimum m/z of the peak.  
**mzmax** Maximum m/z of the peak.  
**rt** Retention time of the peak’s midpoint.  
**rtmin** Minimum retention time of the peak.  
**rtmax** Maximum retention time of the peak.  
**into** Integrated (original) intensity of the peak.  
**intf** Integrated intensity of the filtered peak.  
**maxo** Maximum intensity of the peak.  
**maxf** Maximum intensity of the filtered peak.  
**i** Rank of peak in merged EIC (<= max).  
**sn** Signal to noise ratio of the peak  

- Grouping has its own methods too (density, mzClust, nearest)  
Q: How do we tune grouping parameters? How do we find the best ones for our data?  
```{r Grouping peaks representing the same analyte across samples / matching peaks across samples}
#?group.density
#?group.mzClust
#?group.nearest

#xsg.pos <- group(xset.pos, sleep = 0.02)

xsg.pos.centw <- group(xset.pos.centw)
xsg.pos.mquant <- group(xset.pos.mquant)

xsg.neg.centw <- group(xset.neg.centw)
xsg.neg.mquant <- group(xset.neg.mquant)

xsg.pos.centw.mzClust <- group.mzClust(xset.pos.centw, mzppm = 5)
xsg.pos.mquant.mzClust <- group.mzClust(xset.pos.mquant, mzppm = 5)

xsg.neg.centw.mzClust <- group.mzClust(xset.neg.centw, mzppm = 5)
xsg.neg.mquant.mzClust <- group.mzClust(xset.neg.mquant, mzppm = 5)
```


There are a few retention time correction methods in xcms: Gaussian, Symmetric, and Obiwarp.  
Plot shows the data points used for regression and the resulting deviation profiles. It can be used for supervising the algorithm. The distribution of peak groups across retention time is also shown in the plot.  
```{r Retention time correction}
xsg.pos.centw.retcor <- retcor(xsg.pos.centw, family="gaussian", plottype="mdevden")
xsg.pos.mquant.retcor <- retcor(xsg.pos.mquant, family="gaussian", plottype="mdevden")

xsg.neg.centw.retcor <- retcor(xsg.neg.centw, family="gaussian", plottype="mdevden")
xsg.neg.mquant.retcor <- retcor(xsg.neg.mquant, family="gaussian", plottype="mdevden")

xsg.pos.centw.mzClust.retcor <- retcor(xsg.pos.centw.mzClust, family="gaussian", plottype="mdevden")
xsg.pos.mquant.mzClust.retcor <- retcor(xsg.pos.mquant.mzClust, family="gaussian", plottype="mdevden")

xsg.neg.centw.mzClust.retcor <- retcor(xsg.neg.centw.mzClust, family="gaussian", plottype="mdevden")
xsg.neg.mquant.mzClust.retcor <- retcor(xsg.neg.mquant.mzClust, family="gaussian", plottype="mdevden")

#xsg.pos.retcor.symmetric <- retcor(xsg.pos, family="symmetric", plottype="mdevden")
#xsg.pos.retcor.obiwarp <- retcor.obiwarp(xsg.pos, plottype="deviation")

xsg.pos.centw.retcor.obiwarp <- retcor.obiwarp(xsg.pos.centw, plottype="deviation")
xsg.pos.mquant.retcor.obiwarp <- retcor.obiwarp(xsg.pos.mquant, plottype="deviation")

xsg.neg.centw.retcor.obiwarp <- retcor.obiwarp(xsg.neg.centw, plottype="deviation")
xsg.neg.mquant.retcor.obiwarp <- retcor.obiwarp(xsg.neg.mquant, plottype="deviation")

xsg.pos.centw.mzClust.retcor.obiwarp <- retcor.obiwarp(xsg.pos.centw.mzClust, plottype="deviation")
xsg.pos.mquant.mzClust.retcor.obiwarp <- retcor.obiwarp(xsg.pos.mquant.mzClust, plottype="deviation")

xsg.neg.centw.mzClust.retcor.obiwarp <- retcor.obiwarp(xsg.neg.centw.mzClust, plottype="deviation")
xsg.neg.mquant.mzClust.retcor.obiwarp <- retcor.obiwarp(xsg.neg.mquant.mzClust, plottype="deviation")
```


When re-grouping the retention time-corrected xset, parameters can also be re-tuned once more. For example, we can choose a narrower 'bw'.  
```{r Re-grouping peaks representing the same analyte across samples. Grouping/retention time correction can and must be repeated several times}
xsg.gaus.pos <- group(xsg.pos.mquant.mzClust.retcor.obiwarp)
xsg.gaus.pos <- retcor.obiwarp(xsg.gaus.pos, plottype="deviation")
xsg.gaus.pos <- group(xsg.gaus.pos)

xsg.gaus.neg <- group(xsg.neg.mquant.mzClust.retcor.obiwarp)
xsg.gaus.neg <- retcor(xsg.gaus.neg, family="gaussian", plottype="mdevden")
xsg.gaus.neg <- group(xsg.gaus.neg)

#xsg.sym <- group(xsg.pos.retcor.symmetric, bw=10)
#xsg.obw <- group(xsg.pos.retcor.obiwarp, bw=10)
```


```{r Fill in missing peaks using original data, message=FALSE, warning=FALSE}
xsg.gaus.pos <- fillPeaks(xsg.gaus.pos)
xsg.gaus.neg <- fillPeaks(xsg.gaus.neg)
#xsg.sym <- fillPeaks(xsg.sym)
#xsg.obw <- fillPeaks(xsg.obw)
```


```{r QC}

###intensity
boxplot(groupval(xsg.gaus.pos, value="into")+1, 
        col=as.numeric(sampclass(xsg.gaus.pos))+1, 
        log="y", las=2)

plotQC(xsg.gaus.pos)

sdThresh <- 4.0 ## Filter low-standard deviation rows for plot
data <- log(groupval(xsg.gaus.pos, value="into")+1)

pca.result <- pcaMethods::pca(data, nPcs = 8)
pcaMethods::plotPcs(pca.result, type="loadings", 
        col=as.numeric(sampclass(xsg.gaus.pos))+1)

pcares <- as.data.frame(pca.result@loadings)

plotly::plot_ly(pcares, x = ~PC1, y = ~PC2, z = ~PC3, color = (sampclass(xsg.gaus.pos)), colors = c("#377EB8", "#4DAF4A")) %>%
    add_markers() %>%
    layout(scene = list(xaxis = list(title = 'PC #1'),
                        yaxis = list(title = 'PC #2'),
                        zaxis = list(title = 'PC #3')))

#pca <- prcomp(t(data), scale.=TRUE)
#gr <- factor(as.numeric(sampclass(xsg.gaus))+1)
#summary(gr)
#pca3d(pca, group=gr)
```


"into" and "maxo" are (or at least seem to be) peak intensities and areas, respectively.  
Peak list:  
```{r Results of peak detection}
peaks(xsg.gaus.pos)[1:25,]
dim(xsg.gaus.pos@peaks)
#dim(peaks(xsg.gaus.pos)) ### Another way of doing what was done in the previous line

peaks(xsg.gaus.neg)[1:25,]
dim(xsg.gaus.neg@peaks)
```


‘diffreport’ computes Welch's two-sample t-statistic for each analyte and ranks them by p-value. In brief, it performs univariate analysis on our peaks.  
Q: When using 'diffreport', it is possible to include three sample classes (or even many more) by defining the class1/class2 arguments as c("sample2","sample3"). Does that, however, have any impact on the final result? In brief, is there a difference between `class1=c("Mouse1", "Mouse2"), class2="Mouse5"` and `class1="Mouse1", class2=c("Mouse2","Mouse5")`  
```{r Extracting ion chromatograms for significant ions and reporting the most statistically significant differences in analyte intensities / A report showing the most significant differences between two sets of samples, message=FALSE}
rep.gaus.pos <- diffreport(object = xsg.gaus.pos, 
                       class1 = levels(sampclass(xsg.gaus.pos))[1], 
                       class2 = levels(sampclass(xsg.gaus.pos))[2], 
                       filebase = "diffreport_ESI_pos", eicmax = 40, 
                       sortpval = TRUE,
                       metlin = 0.5, mzdec = 5)

rep.gaus.neg <- diffreport(object = xsg.gaus.neg, 
                       class1 = levels(sampclass(xsg.gaus.neg))[1], 
                       class2 = levels(sampclass(xsg.gaus.neg))[2], 
                       filebase = "diffreport_ESI_neg", eicmax = 40, 
                       sortpval = TRUE,
                       metlin = 0.5, mzdec = 5)

#### quality of peaks can be inspected by checking the figures in report_eic folder

#rep.sym <- diffreport(xsg.sym, "Fresh", c("Frozen 1w", "Frozen 24h"), "Symmetric", 10, metlin=0.15)
#rep.obw <- diffreport(xsg.obw, "Fresh", c("Frozen 1w", "Frozen 24h"), "Obiwarp", 10, metlin=0.15)

rep.gaus.pos[1:25,]
tail(rep.gaus.pos)

rep.gaus.neg[1:25,]
tail(rep.gaus.neg)

#rep.sym[1:10,]
#rep.obw[1:10,]
```

```{r DifferentPeaks}
eic <- list.files("diffreport_eic", full.names = T, recursive = T)
im <- list()
for(i in 1:length(eic)) {
  im[[i]] <- load.image(eic[i])
  plot(im[[i]])
  }

```


```{r Constructing peak intensity matrix for multivariate analysis using MetaboAnalyst.ca}
#– Features (peaks) are in rows
#– Samples are in  columns
#– Group labels must be added by using 'phenoData'
#- If there are duplicated mzRT values in the rows of the generated peak intensity matrix, MetaboAnalyst will result in an error. To fix this error, simply distinguish repeated values by adding 'A', 'B', 'C', etc. to them. For example, if you have the mzRT feature 54.04/1499.3 twice in the resulting table, simply change the second one to 54.04/1499.3A
dat <- groupval(xsg.gaus.pos, "medret", "into")
rownames(dat) <- groupnames(xsg.gaus.pos, mzdec=5, rtdec=5)
dat <- rbind(group = as.character(phenoData(xsg.gaus.pos)$class), dat)
write.csv(dat, file='ESI+_PeakIntensityMatrix_MetaboAnalyst.csv')
head(dat)
tail(dat)
#rm(dat)

datneg <- groupval(xsg.gaus.neg, "medret", "into")
rownames(datneg) <- groupnames(xsg.gaus.neg, mzdec=5, rtdec=5)
datneg <- rbind(group = as.character(phenoData(xsg.gaus.neg)$class), datneg)
write.csv(datneg, file='ESI-_PeakIntensityMatrix_MetaboAnalyst.csv')
head(datneg)
tail(datneg)
#rm(datneg)

#dat <- groupval(xsg.sym, "medret", "into")
#dat <- rbind(group = as.character(phenoData(xsg.sym)$class), dat)
#write.csv(dat, file='Symmetric_PeakIntensityMatrix.csv')
#rm(dat)

#dat <- groupval(xsg.obw, "medret", "into")
#dat <- rbind(group = as.character(phenoData(xsg.obw)$class), dat)
#write.csv(dat, file='Obiwarp_PeakIntensityMatrix.csv')
#rm(dat)
```

```{r Extracted ion chromatogram (EIC) / Assessing the quality of detected peaks}
#gt.gaus <- groups(xsg.gaus)
#gt.gaus[1:3,]

#gt.sym <- groups(xsg.sym)
#gt.sym[1:3,]

#gt.obw <- groups(xsg.obw)
#gt.obw[1:3,]

#grp_idx_gaus <- which(gt.gaus[,"rtmed"] > 0 & gt.gaus[,"rtmed"] < 500 & gt.gaus[,"npeaks"] > 50)[1]
#eiccor.gaus <- getEIC(xsg.gaus, groupidx=grp_idx_gaus)
#plot(eiccor.gaus, col=as.numeric(phenoData(xsg.gaus)$class))
```

"Derivative signals such as isotopes, adducts, dimers and fragments, can be automatically annotated by correlation analysis on both signal shape and intensity patterns using software tools like CAMERA, PUTMEDID-LCMS and mzMatch. Such peaks are not discarded, but only flagged, so that their assigned annotations can be taken into account in the metabolite identification step."
```{r Isotope and Adduct Detection --- UNDER DEVELOPMENT | Be cautious}
an <- xsAnnotate(xsg.gaus, polarity="positive") # constructor; extracts peak table
an <- groupFWHM(an, perfwhm = 1) # group peaks by retention time
#an <- findIsotopesWithValidation(object = an, ppm = 5, mzabs = 0.01, intval="intb", maxcharge = 3)
peakTable <- getPeaklist(an) # extract peak list
head(peakTable)
tail(peakTable)
an <- groupCorr(an)
anF <- findIsotopes(an)
anF <- findAdducts(anF, polarity="positive")
write.csv(getPeaklist(anF),file="isotope_adduct_prediction.csv")
getPeaklist(anF)
```

```{r Independent Component Analysis (ICA) / T-distributed Stochastic Neighbor Embedding (tSNE) --- UNDER DEVELOPMENT | Be cautious}
t <- dat
head(t)
labels.plot <- t[1,][-1]
t <- t[-1,]

# for(i in 1:dim(t)[2]){
# t[,i] <- as.numeric(as.character(t[,i]))
# }

write.csv(x = t, file = "t.csv")
t <- (read.csv("t.csv", header = TRUE, stringsAsFactors = FALSE, row.names = 1, check.names = FALSE))

tICA <- fastICA::fastICA(t, n.comp = 2)

sample_colors <- brewer.pal(2, "Set1")[1:2]
names(sample_colors) <- unique(labels.plot)
cols <- paste0(sample_colors[labels.plot], 80)
tTSNE.features <- Rtsne(t)
tTSNE.samples <- Rtsne(t(t), perplexity = 4)
#par(mfrow=c(3,1))
plot(tICA$S, col=cols, cex=2, pch=16, main="Independent Component Analysis (ICA)\nSamples")
plot(tTSNE.features$Y, main = "T-distributed Stochastic Neighbor Embedding (tSNE)\nFeatures")
plot(tTSNE.samples$Y, main="T-distributed Stochastic Neighbor Embedding (tSNE)\nSamples", col=cols, pch=16, cex=3)
```

```{r Metabolite Identification using MassBank of North America}
significant_features_mz <- c(902.433, 532.044, 122.456) ### this list comes from prior statistical analysis
identified <- list(NULL)
ionization_mode <- "positive"
mz_tolerance <- 0.5

for(i in 1:length(significant_features_mz)){
  lower_bound <- significant_features_mz[i] - mz_tolerance
  upper_bound <- significant_features_mz[i] + mz_tolerance
  identified[[i]] <- jsonlite::fromJSON(paste0("http://mona.fiehnlab.ucdavis.edu/rest/spectra/search?page=0&query=compound.metaData%3Dq%3D%27name%3D%3D%22total+exact+mass%22+and+value+%3E%3D+", lower_bound, "+and+value+%3C%3D+", upper_bound,
"%27+and+(tags.text%3D%3D%22LC-MS%22)+and+(metaData%3Dq%3D%27name%3D%3D%22ionization+mode%22+and+value%3D%3D%22positive%22%27)+and+(metaData%3Dq%3D%27name%3D%3D%22ms+level%22+and+value%3D%3D%22MS1%22%27)&size=30&text="))
  Sys.sleep(time = 5) ### introduce a small pause between searches to avoid IP ban
}

identified[[1]]$metaData[[1]]$value
identified[[1]]$compound[[1]]$inchi
identified[[1]]$compound[[1]]$names
lapply(identified[[1]]$compound, `[`, 4) ### name of all hits for the first m/z value
identified[[1]]$compound[[1]]$classification
identified[[1]]$compound[[1]]$metaData[[1]]

#decoded.url <- jsonlite::fromJSON("http://mona.fiehnlab.ucdavis.edu/rest/spectra/search?page=0&query=compound.metaData=q='name=="total exact mass" and value >= 245 and value <= 255' and (tags.text=="LC-MS") and (metaData=q='name=="ionization mode" and value=="positive"') and (metaData=q='name=="ms level" and value=="MS1"')&size=30&text=")

#utils::URLdecode()
```

```{r Metabolite identification using Metlin}
significant_features_mz <- c(418.2931, 540.29)
mz_tolerance_ppm <- 5

### Charge is ESI+
### Adduct: M+H

metlin_table <- list(NULL)
metlin_res <- list(NULL)
metlin_res_tbl <- list(NULL)

for(i in length(significant_features_mz)){
  metlin_table[[i]] <- xml2::read_html(paste0('https://metlin.scripps.edu/simple_search_result.php?mass_mid=', significant_features_mz[i],
       '&mass_tol=', mz_tolerance_ppm, '&mass_mode=1&AminoAcid=add&toxinEPA=add&adducts=M%2BH'))
  metlin_res[[i]] <- rvest::html_nodes(metlin_table[[i]], "table")
  metlin_res_tbl[[i]] <- rvest::html_table(metlin_res[[i]][1], fill = TRUE)
  print(head(metlin_res_tbl[[i]][[1]]))
}
```

Processing with peakML  
```{r PeakML}
source ("http://puma.ibls.gla.ac.uk/mzmatch.R/install_mzmatch.R")
.jinit ()
mzmatch.init()
PeakML.xcms.write(xsg.gaus.neg, "xsg_gaus_neg.peakml")
mzmatch.init(version.1 = FALSE)
mzmatch.ipeak.sort.MetAssign(JHeapSize = 180000, i = "xsg_gaus_neg.peakml", o = "xcms_identified.peakml", 
                             basepeaks = "xcms_basepeaks.peakml", ppm = 3, numDraws = 300, burnIn = 200, 
                             adducts = "M+H,M+NH4", 
                             dbIdentOut = "xcms_neg_Probabilistic_metabolite_annotation.csv", v = TRUE)

### PeakML.Viewer() ### Load generated peakML files
```

```{r apLCMS pipeline}
#####This section is currently under construction (apLCMS might not be as reliable as xcms)
#apLCMS.set <- apLCMS::cdf.to.ftr(path.pos, file.pattern = ".mzXML")
```

```{r IPO / XCMS Parameter Optimization, eval=FALSE}
peakpickingParameters <- IPO::getDefaultXcmsSetStartingParams('centWave')
peakpickingParameters$min_peakwidth <- c(12,35)
peakpickingParameters$max_peakwidth <- c(15, 65)
peakpickingParameters$ppm <- c(10,40)
peakpickingParameters$step <- c(0.1, 1)
peakpickingParameters$snthresh <- c(10,80)
peakpickingParameters$noise <- 5000
peakpickingParameters$prefilter <- c(3,5)
peakpickingParameters$value_of_prefilter <- c(3000,15000)
peakpickingParameters$fitgauss <- TRUE

peakpickingParameters$fwhm <- c(2,60)
peakpickingParameters$sigma <- 0
peakpickingParameters$steps <- c(1,10)
peakpickingParameters$index <- FALSE
peakpickingParameters$max <- 5

data <- list.files("data/Rik/ESI+/", recursive = T, full.names = T, pattern = ".mzML")
optimized.xcmsSet <- system.time({
    resultPeakpicking <- optimizeXcmsSet(files = data, 
                       params = peakpickingParameters,
                       nSlaves = 70,
                       subdir = "IPO_plots")
})

```

```{r Mixture Model Normalization with metabomxtr}
### https://bioconductor.org/packages/release/bioc/vignettes/metabomxtr/inst/doc/mixnorm_Vignette.pdf
### We can use the peak intensity matrix that was generated for MetaboAnalyst
### However, samples should be in rows and metabolites in columns
### Two additional columns are needed to specify 'phenotype' group and 'batch' (run) number


```

```{r XCMS3 Pipeline}
files.path <- "LCMS-Data/Mzb1/"
mzml.files <- list.files(files.path, recursive = T, full.names = T, pattern=".mzML")
mzml.files

pd <- data.frame(sample_name = sub(basename(mzml.files), pattern = ".mzML",
                   replacement = "", fixed = TRUE),
         sample_group = c(rep("Mzb1", 7), rep("WT", 6)),
         stringsAsFactors = FALSE) 

raw_data <- readMSData(files = mzml.files, pdata = new("NAnnotatedDataFrame", pd), mode = "onDisk")

head(rtime(raw_data)) 

mzs <- mz(raw_data)

## Split the list by file
mzs_by_file <- split(mzs, f = fromFile(raw_data))

length(mzs_by_file) 

## Get the base peak chromatograms. This reads data from the files.
bpis <- chromatogram(raw_data, aggregationFun = "max")
tic <- chromatogram(raw_data, aggregationFun = "sum")
## Define colors for the two groups
group_colors <- brewer.pal(3, "Set1")[1:2]
names(group_colors) <- c("Mzb1", "WT")

## Plot all chromatograms.
plot(bpis, col = group_colors[raw_data$sample_group], main = "Base Peak Chromatogram (BPC)")
plot(tic, col = group_colors[raw_data$sample_group], main = "Total Ion Current (TIC)")

bpi_1 <- bpis[1, 1]
head(rtime(bpi_1))

head(intensity(bpi_1)) 

## Get the total ion current by file
tc <- split(tic(raw_data), f = fromFile(raw_data))
boxplot(tc, col = group_colors[raw_data$sample_group],
    ylab = "intensity", main = "Total ion current") 

## Visually inspect the EIC of internal controls, known peaks, etc.
## Peak widths can be inspected in this way as well, and in turn help us to choose
## better peak widths for centWave or other algorithms.
## Use TopView to the same as well.

#Note that Chromatogram objects extracted by the chromatogram method contain an NA value if in a certain scan (i.e. for a specific retention time) no signal was measured in the respective mz range. This is reflected by the lines not being drawn as continuous lines in the plot above.

## Define the rt and m/z range of the peak area
rtr <- c(92.60, 200)
mzr <- c(118.07, 118.19)
## extract the chromatogram
chr_raw <- chromatogram(raw_data, mz = mzr, rt = rtr)
plot(chr_raw, col = group_colors[chr_raw$sample_group])


## For the ppm parameter we extract the full MS data (intensity, retention time and m/z values) corresponding to the above peak.
## the ppm parameter is usually set to a much higher value than advertised by the vendor of the machine
## Extract the MS data for the region.
msd_raw <- extractMsData(raw_data, mz = mzr, rt = rtr)
plotMsData(msd_raw[[1]]) 

## Inspect the lower panel
## If you see a straight line, this means there is no variation in the m/z values for that particular peak
## Usually one would see the m/z values (lower panel) scatter around the real m/z value of the compound. It is suggested to inspect the ranges of m/z values for many compounds (either internal standards or compounds known to be present in the sample) and define the ppm parameter for centWave according to these.

cwp <- CentWaveParam(peakwidth = c(15, 45), noise = 12000)
xdata <- findChromPeaks(raw_data, param = cwp)
head(chromPeaks(xdata)) 

#The returned matrix provides the m/z and retention time range for each identified chromatographic peak as well as the integrated signal intensity (“into”) and the maximal peak intensitity (“maxo”). Column “sample” contains the index of the sample in the object/experiment in which the peak was identified.


### per file (sample) statistics
summary_fun <- function(z) {
    c(peak_count = nrow(z), rt = quantile(z[, "rtmax"] - z[, "rtmin"]))
}
T <- lapply(split.data.frame(chromPeaks(xdata),
                 f = chromPeaks(xdata)[, "sample"]),
        FUN = summary_fun)
T <- do.call(rbind, T)
rownames(T) <- basename(fileNames(xdata))
pander::pandoc.table(T,
         caption = paste0("Summary statistics on identified chromatographic",
                  " peaks. Shown are number of identified peaks per",
                  " sample and widths/duration of chromatographic ",
                  "peaks.")) 

### plot the location of the identified chromatographic peaks in the m/z - retention time space for one file
plotChromPeaks(xdata, file = 3) 


### plot the frequency of identified peaks per file along the retention time axis. This allows to identify time periods along the MS run in which a higher number of peaks was identified and evaluate whether this is consistent across files.
### The frequency is color coded with higher frequency being represented by yellow-white.
plotChromPeakImage(xdata) 


## Highlight identified peaks
rtr = c(1070,1100)
mzr = c(149,150)
chr_raw <- chromatogram(raw_data, mz = mzr, rt = rtr)
plot(chr_raw, col = group_colors[chr_raw$sample_group], lwd = 2)
highlightChromPeaks(xdata, border = group_colors[chr_raw$sample_group],
                    lty = 3, rt = rtr, mz = mzr)

## Extract identified peaks in a region
pander(chromPeaks(xdata, mz = mzr, rt = rtr),
       caption = paste("Identified chromatographic peaks in a selected ",
               "m/z and retention time range.")) 


### distribution of peak intensity per sample
## Extract a list of per-sample peak intensities (in log2 scale)
ints <- split(log2(chromPeaks(xdata)[, "into"]),
          f = chromPeaks(xdata)[, "sample"])
boxplot(ints, varwidth = TRUE, col = group_colors[xdata$sample_group],
    ylab = expression(log[2]~intensity), main = "Peak intensities")
grid(nx = NA, ny = NULL) 


#The time at which analytes elute in the chromatography can vary between samples (and even compounds). Such a difference can be inspected using the extracted ion chromatogram plots. The alignment step, also referred to as retention time correction, aims at adjusting this by shifting signals along the retention time axis to align the signals between different samples within an experiment.

#adjustRtime, besides calculating adjusted retention times for each spectrum, does also adjust the reported retention times of the identified chromatographic peaks.


xdata <- adjustRtime(xdata, param = ObiwarpParam(binSize = 0.6))
head(adjustedRtime(xdata))
head(rtime(xdata))  ### defaults to adjustedRtime if it's present
head(rtime(xdata, adjusted = FALSE)) ### returns original retention times


### investigate the impact of alignment by plotting BPC of the adjusted data
#To evaluate the impact of the alignment we plot the BPC on the adjusted data. In addition we plot the differences of the adjusted- to the raw retention times per sample using the  plotAdjustedRtime function.
#Too large differences between adjusted and raw retention times could indicate poorly performing samples or alignment.
## Get the base peak chromatograms.
bpis_adj <- chromatogram(xdata, aggregationFun = "max")
par(mfrow = c(2, 1), mar = c(4.5, 4.2, 1, 0.5))
plot(bpis_adj, col = group_colors[bpis_adj$sample_group])
## Plot also the difference of adjusted to raw retention time.
plotAdjustedRtime(xdata, col = group_colors[xdata$sample_group]) 


#use the peak groups alignment method that adjusts the retention time by aligning previously identified hook peaks (chromatographic peaks present in most/all samples). Ideally, these hook peaks should span most part of the retention time range. 
hasAdjustedRtime(xdata)
xdata <- dropAdjustedRtime(xdata)
hasAdjustedRtime(xdata)


#The definition of the sample groups (i.e. assignment of individual samples to the sample groups in the experiment) is mandatory for the PeakDensityParam. If there are no sample groups in the experiment sampleGroups should be set to a single value for each file (e.g.  rep(1, length(fileNames(xdata))).

x = split(mz(raw_data), f = fromFile(raw_data))
y = split(intensity(raw_data), f = fromFile(raw_data))
z = (split(rtime(raw_data), f = fromFile(raw_data)))
dl <- data.frame(mz = unlist(x$`1`), int = unlist(y$`1`), rt = rep(z$`1`, (Biobase::listLen(x$`1`))))
p <- plot_ly(x = dl$mz, y = dl$int, z = as.matrix(dl$rt)) %>% add_surface() ## surface 3D plot
p
```